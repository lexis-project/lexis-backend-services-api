// Code generated by go-swagger; DO NOT EDIT.

package data_set_management

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"net/http"

	"github.com/go-openapi/runtime"

	"github.com/lexis-project/lexis-backend-services-api.git/models"
)

// CompressEncryptCreatedCode is the HTTP code returned for type CompressEncryptCreated
const CompressEncryptCreatedCode int = 201

/*CompressEncryptCreated The response code means that the compression and encryption has been initiated. Status of the operation can be checked by querying the status.

swagger:response compressEncryptCreated
*/
type CompressEncryptCreated struct {

	/*
	  In: Body
	*/
	Payload *models.SteeringRequestID `json:"body,omitempty"`
}

// NewCompressEncryptCreated creates CompressEncryptCreated with default headers values
func NewCompressEncryptCreated() *CompressEncryptCreated {

	return &CompressEncryptCreated{}
}

// WithPayload adds the payload to the compress encrypt created response
func (o *CompressEncryptCreated) WithPayload(payload *models.SteeringRequestID) *CompressEncryptCreated {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the compress encrypt created response
func (o *CompressEncryptCreated) SetPayload(payload *models.SteeringRequestID) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *CompressEncryptCreated) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(201)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// CompressEncryptBadRequestCode is the HTTP code returned for type CompressEncryptBadRequest
const CompressEncryptBadRequestCode int = 400

/*CompressEncryptBadRequest This means that there's something wrong in the input parameters and the server couldn't understand the request.

swagger:response compressEncryptBadRequest
*/
type CompressEncryptBadRequest struct {

	/*
	  In: Body
	*/
	Payload *models.ErrorResponse `json:"body,omitempty"`
}

// NewCompressEncryptBadRequest creates CompressEncryptBadRequest with default headers values
func NewCompressEncryptBadRequest() *CompressEncryptBadRequest {

	return &CompressEncryptBadRequest{}
}

// WithPayload adds the payload to the compress encrypt bad request response
func (o *CompressEncryptBadRequest) WithPayload(payload *models.ErrorResponse) *CompressEncryptBadRequest {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the compress encrypt bad request response
func (o *CompressEncryptBadRequest) SetPayload(payload *models.ErrorResponse) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *CompressEncryptBadRequest) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(400)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// CompressEncryptUnauthorizedCode is the HTTP code returned for type CompressEncryptUnauthorized
const CompressEncryptUnauthorizedCode int = 401

/*CompressEncryptUnauthorized This means that the user is not authenticated with keycloak and compression with encryption can't be triggered unless the user first log in with a valid user

swagger:response compressEncryptUnauthorized
*/
type CompressEncryptUnauthorized struct {

	/*
	  In: Body
	*/
	Payload *models.ErrorResponse `json:"body,omitempty"`
}

// NewCompressEncryptUnauthorized creates CompressEncryptUnauthorized with default headers values
func NewCompressEncryptUnauthorized() *CompressEncryptUnauthorized {

	return &CompressEncryptUnauthorized{}
}

// WithPayload adds the payload to the compress encrypt unauthorized response
func (o *CompressEncryptUnauthorized) WithPayload(payload *models.ErrorResponse) *CompressEncryptUnauthorized {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the compress encrypt unauthorized response
func (o *CompressEncryptUnauthorized) SetPayload(payload *models.ErrorResponse) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *CompressEncryptUnauthorized) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(401)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// CompressEncryptForbiddenCode is the HTTP code returned for type CompressEncryptForbidden
const CompressEncryptForbiddenCode int = 403

/*CompressEncryptForbidden This means that the resource the user is trying to compress and encrypt is not readable by the user. User doesn't have the correct rights to read the source file.

swagger:response compressEncryptForbidden
*/
type CompressEncryptForbidden struct {

	/*
	  In: Body
	*/
	Payload *models.ErrorResponse `json:"body,omitempty"`
}

// NewCompressEncryptForbidden creates CompressEncryptForbidden with default headers values
func NewCompressEncryptForbidden() *CompressEncryptForbidden {

	return &CompressEncryptForbidden{}
}

// WithPayload adds the payload to the compress encrypt forbidden response
func (o *CompressEncryptForbidden) WithPayload(payload *models.ErrorResponse) *CompressEncryptForbidden {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the compress encrypt forbidden response
func (o *CompressEncryptForbidden) SetPayload(payload *models.ErrorResponse) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *CompressEncryptForbidden) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(403)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// CompressEncryptNotFoundCode is the HTTP code returned for type CompressEncryptNotFound
const CompressEncryptNotFoundCode int = 404

/*CompressEncryptNotFound This means that either the source path on the system doesn't exist.

swagger:response compressEncryptNotFound
*/
type CompressEncryptNotFound struct {

	/*
	  In: Body
	*/
	Payload *models.ErrorResponse `json:"body,omitempty"`
}

// NewCompressEncryptNotFound creates CompressEncryptNotFound with default headers values
func NewCompressEncryptNotFound() *CompressEncryptNotFound {

	return &CompressEncryptNotFound{}
}

// WithPayload adds the payload to the compress encrypt not found response
func (o *CompressEncryptNotFound) WithPayload(payload *models.ErrorResponse) *CompressEncryptNotFound {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the compress encrypt not found response
func (o *CompressEncryptNotFound) SetPayload(payload *models.ErrorResponse) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *CompressEncryptNotFound) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(404)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// CompressEncryptRequestURITooLongCode is the HTTP code returned for type CompressEncryptRequestURITooLong
const CompressEncryptRequestURITooLongCode int = 414

/*CompressEncryptRequestURITooLong This means that the source path is longer than the server is willing to interpret.

swagger:response compressEncryptRequestUriTooLong
*/
type CompressEncryptRequestURITooLong struct {

	/*
	  In: Body
	*/
	Payload *models.ErrorResponse `json:"body,omitempty"`
}

// NewCompressEncryptRequestURITooLong creates CompressEncryptRequestURITooLong with default headers values
func NewCompressEncryptRequestURITooLong() *CompressEncryptRequestURITooLong {

	return &CompressEncryptRequestURITooLong{}
}

// WithPayload adds the payload to the compress encrypt request Uri too long response
func (o *CompressEncryptRequestURITooLong) WithPayload(payload *models.ErrorResponse) *CompressEncryptRequestURITooLong {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the compress encrypt request Uri too long response
func (o *CompressEncryptRequestURITooLong) SetPayload(payload *models.ErrorResponse) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *CompressEncryptRequestURITooLong) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(414)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// CompressEncryptTooManyRequestsCode is the HTTP code returned for type CompressEncryptTooManyRequests
const CompressEncryptTooManyRequestsCode int = 429

/*CompressEncryptTooManyRequests This means that the user has sent too many requests in a given amount of time. The user is advised to wait and send the request again.

swagger:response compressEncryptTooManyRequests
*/
type CompressEncryptTooManyRequests struct {

	/*
	  In: Body
	*/
	Payload *models.ErrorResponse `json:"body,omitempty"`
}

// NewCompressEncryptTooManyRequests creates CompressEncryptTooManyRequests with default headers values
func NewCompressEncryptTooManyRequests() *CompressEncryptTooManyRequests {

	return &CompressEncryptTooManyRequests{}
}

// WithPayload adds the payload to the compress encrypt too many requests response
func (o *CompressEncryptTooManyRequests) WithPayload(payload *models.ErrorResponse) *CompressEncryptTooManyRequests {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the compress encrypt too many requests response
func (o *CompressEncryptTooManyRequests) SetPayload(payload *models.ErrorResponse) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *CompressEncryptTooManyRequests) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(429)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// CompressEncryptInternalServerErrorCode is the HTTP code returned for type CompressEncryptInternalServerError
const CompressEncryptInternalServerErrorCode int = 500

/*CompressEncryptInternalServerError This means that something has gone wrong on the burst buffer. The user is advised to wait and send the request again.

swagger:response compressEncryptInternalServerError
*/
type CompressEncryptInternalServerError struct {

	/*
	  In: Body
	*/
	Payload *models.ErrorResponse `json:"body,omitempty"`
}

// NewCompressEncryptInternalServerError creates CompressEncryptInternalServerError with default headers values
func NewCompressEncryptInternalServerError() *CompressEncryptInternalServerError {

	return &CompressEncryptInternalServerError{}
}

// WithPayload adds the payload to the compress encrypt internal server error response
func (o *CompressEncryptInternalServerError) WithPayload(payload *models.ErrorResponse) *CompressEncryptInternalServerError {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the compress encrypt internal server error response
func (o *CompressEncryptInternalServerError) SetPayload(payload *models.ErrorResponse) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *CompressEncryptInternalServerError) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(500)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}
