// Code generated by go-swagger; DO NOT EDIT.

package data_set_management

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"net/http"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NewFilePatchParams creates a new FilePatchParams object
// no default values defined in spec.
func NewFilePatchParams() FilePatchParams {

	return FilePatchParams{}
}

// FilePatchParams contains all the bound params for the file patch operation
// typically these are obtained from a http.Request
//
// swagger:parameters FilePatch
type FilePatchParams struct {

	// HTTP Request Object
	HTTPRequest *http.Request `json:"-"`

	/*
	  In: body
	*/
	Body string
	/*
	  Required: true
	  In: header
	*/
	ContentLength int64
	/*Protocol version
	  Required: true
	  In: header
	*/
	TusResumable string
	/*Added by the checksum extension. The Upload-Checksum request header contains information about the checksum of the current body payload. The header MUST consist of the name of the used checksum algorithm and the Base64 encoded checksum separated by a space.
	  In: header
	*/
	UploadChecksum *string
	/*The Upload-Offset request and response header indicates a byte offset within a resource. The value MUST be a non-negative integer.
	  Required: true
	  In: header
	*/
	UploadOffset int64
	/*
	  Required: true
	  In: path
	*/
	ID string
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls.
//
// To ensure default values, the struct must have been initialized with NewFilePatchParams() beforehand.
func (o *FilePatchParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
	var res []error

	o.HTTPRequest = r

	if runtime.HasBody(r) {
		defer r.Body.Close()
		var body string
		if err := route.Consumer.Consume(r.Body, &body); err != nil {
			res = append(res, errors.NewParseError("body", "body", "", err))
		} else {
			// no validation required on inline body
			o.Body = body
		}
	}
	if err := o.bindContentLength(r.Header[http.CanonicalHeaderKey("Content-Length")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	if err := o.bindTusResumable(r.Header[http.CanonicalHeaderKey("Tus-Resumable")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	if err := o.bindUploadChecksum(r.Header[http.CanonicalHeaderKey("Upload-Checksum")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	if err := o.bindUploadOffset(r.Header[http.CanonicalHeaderKey("Upload-offset")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	rID, rhkID, _ := route.Params.GetOK("id")
	if err := o.bindID(rID, rhkID, route.Formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// bindContentLength binds and validates parameter ContentLength from header.
func (o *FilePatchParams) bindContentLength(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("Content-Length", "header", rawData)
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true

	if err := validate.RequiredString("Content-Length", "header", raw); err != nil {
		return err
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("Content-Length", "header", "int64", raw)
	}
	o.ContentLength = value

	return nil
}

// bindTusResumable binds and validates parameter TusResumable from header.
func (o *FilePatchParams) bindTusResumable(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("Tus-Resumable", "header", rawData)
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true

	if err := validate.RequiredString("Tus-Resumable", "header", raw); err != nil {
		return err
	}

	o.TusResumable = raw

	if err := o.validateTusResumable(formats); err != nil {
		return err
	}

	return nil
}

// validateTusResumable carries on validations for parameter TusResumable
func (o *FilePatchParams) validateTusResumable(formats strfmt.Registry) error {

	if err := validate.EnumCase("Tus-Resumable", "header", o.TusResumable, []interface{}{"1.0.0"}, true); err != nil {
		return err
	}

	return nil
}

// bindUploadChecksum binds and validates parameter UploadChecksum from header.
func (o *FilePatchParams) bindUploadChecksum(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	o.UploadChecksum = &raw

	return nil
}

// bindUploadOffset binds and validates parameter UploadOffset from header.
func (o *FilePatchParams) bindUploadOffset(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("Upload-offset", "header", rawData)
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true

	if err := validate.RequiredString("Upload-offset", "header", raw); err != nil {
		return err
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("Upload-offset", "header", "int64", raw)
	}
	o.UploadOffset = value

	return nil
}

// bindID binds and validates parameter ID from path.
func (o *FilePatchParams) bindID(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// Parameter is provided by construction from the route

	o.ID = raw

	return nil
}
