// Code generated by go-swagger; DO NOT EDIT.

package data_set_management

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"net/http"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/swag"

	"github.com/lexis-project/lexis-backend-services-api.git/models"
)

// FilesHeadOKCode is the HTTP code returned for type FilesHeadOK
const FilesHeadOKCode int = 200

/*FilesHeadOK Returns offset

swagger:response filesHeadOK
*/
type FilesHeadOK struct {
	/*Needed to make browsers accept the additional headers used by
	the tus protocol.


	*/
	AccessControlExposeHeaders string `json:"Access-Control-Expose-Headers"`
	/*

	 */
	CacheControl string `json:"Cache-Control"`
	/*Protocol version

	 */
	TusResumable string `json:"Tus-Resumable"`
	/*If the size of the upload is known, the Server MUST include the Upload-Length header in the response.

	 */
	UploadLength int64 `json:"Upload-Length"`
	/*The Upload-Offset request and response header indicates a byte offset within a resource. The value MUST be a non-negative integer. Offset at which the upload should be continued.

	 */
	UploadOffset int64 `json:"Upload-Offset"`
}

// NewFilesHeadOK creates FilesHeadOK with default headers values
func NewFilesHeadOK() *FilesHeadOK {

	return &FilesHeadOK{}
}

// WithAccessControlExposeHeaders adds the accessControlExposeHeaders to the files head o k response
func (o *FilesHeadOK) WithAccessControlExposeHeaders(accessControlExposeHeaders string) *FilesHeadOK {
	o.AccessControlExposeHeaders = accessControlExposeHeaders
	return o
}

// SetAccessControlExposeHeaders sets the accessControlExposeHeaders to the files head o k response
func (o *FilesHeadOK) SetAccessControlExposeHeaders(accessControlExposeHeaders string) {
	o.AccessControlExposeHeaders = accessControlExposeHeaders
}

// WithCacheControl adds the cacheControl to the files head o k response
func (o *FilesHeadOK) WithCacheControl(cacheControl string) *FilesHeadOK {
	o.CacheControl = cacheControl
	return o
}

// SetCacheControl sets the cacheControl to the files head o k response
func (o *FilesHeadOK) SetCacheControl(cacheControl string) {
	o.CacheControl = cacheControl
}

// WithTusResumable adds the tusResumable to the files head o k response
func (o *FilesHeadOK) WithTusResumable(tusResumable string) *FilesHeadOK {
	o.TusResumable = tusResumable
	return o
}

// SetTusResumable sets the tusResumable to the files head o k response
func (o *FilesHeadOK) SetTusResumable(tusResumable string) {
	o.TusResumable = tusResumable
}

// WithUploadLength adds the uploadLength to the files head o k response
func (o *FilesHeadOK) WithUploadLength(uploadLength int64) *FilesHeadOK {
	o.UploadLength = uploadLength
	return o
}

// SetUploadLength sets the uploadLength to the files head o k response
func (o *FilesHeadOK) SetUploadLength(uploadLength int64) {
	o.UploadLength = uploadLength
}

// WithUploadOffset adds the uploadOffset to the files head o k response
func (o *FilesHeadOK) WithUploadOffset(uploadOffset int64) *FilesHeadOK {
	o.UploadOffset = uploadOffset
	return o
}

// SetUploadOffset sets the uploadOffset to the files head o k response
func (o *FilesHeadOK) SetUploadOffset(uploadOffset int64) {
	o.UploadOffset = uploadOffset
}

// WriteResponse to the client
func (o *FilesHeadOK) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	// response header Access-Control-Expose-Headers

	accessControlExposeHeaders := o.AccessControlExposeHeaders
	if accessControlExposeHeaders != "" {
		rw.Header().Set("Access-Control-Expose-Headers", accessControlExposeHeaders)
	}

	// response header Cache-Control

	cacheControl := o.CacheControl
	if cacheControl != "" {
		rw.Header().Set("Cache-Control", cacheControl)
	}

	// response header Tus-Resumable

	tusResumable := o.TusResumable
	if tusResumable != "" {
		rw.Header().Set("Tus-Resumable", tusResumable)
	}

	// response header Upload-Length

	uploadLength := swag.FormatInt64(o.UploadLength)
	if uploadLength != "" {
		rw.Header().Set("Upload-Length", uploadLength)
	}

	// response header Upload-Offset

	uploadOffset := swag.FormatInt64(o.UploadOffset)
	if uploadOffset != "" {
		rw.Header().Set("Upload-Offset", uploadOffset)
	}

	rw.Header().Del(runtime.HeaderContentType) //Remove Content-Type on empty responses

	rw.WriteHeader(200)
}

// FilesHeadUnauthorizedCode is the HTTP code returned for type FilesHeadUnauthorized
const FilesHeadUnauthorizedCode int = 401

/*FilesHeadUnauthorized Authorization failed

swagger:response filesHeadUnauthorized
*/
type FilesHeadUnauthorized struct {

	/*
	  In: Body
	*/
	Payload *models.ErrorResponse `json:"body,omitempty"`
}

// NewFilesHeadUnauthorized creates FilesHeadUnauthorized with default headers values
func NewFilesHeadUnauthorized() *FilesHeadUnauthorized {

	return &FilesHeadUnauthorized{}
}

// WithPayload adds the payload to the files head unauthorized response
func (o *FilesHeadUnauthorized) WithPayload(payload *models.ErrorResponse) *FilesHeadUnauthorized {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the files head unauthorized response
func (o *FilesHeadUnauthorized) SetPayload(payload *models.ErrorResponse) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *FilesHeadUnauthorized) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(401)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// FilesHeadForbiddenCode is the HTTP code returned for type FilesHeadForbidden
const FilesHeadForbiddenCode int = 403

/*FilesHeadForbidden If the resource is not found, the Server SHOULD return either the 404 Not Found, 410 Gone or 403 Forbidden status without the Upload-Offset header.

swagger:response filesHeadForbidden
*/
type FilesHeadForbidden struct {
	/*Needed to make browsers accept the additional headers used by
	the tus protocol.


	*/
	AccessControlExposeHeaders string `json:"Access-Control-Expose-Headers"`
	/*Protocol version

	 */
	TusResumable string `json:"Tus-Resumable"`
}

// NewFilesHeadForbidden creates FilesHeadForbidden with default headers values
func NewFilesHeadForbidden() *FilesHeadForbidden {

	return &FilesHeadForbidden{}
}

// WithAccessControlExposeHeaders adds the accessControlExposeHeaders to the files head forbidden response
func (o *FilesHeadForbidden) WithAccessControlExposeHeaders(accessControlExposeHeaders string) *FilesHeadForbidden {
	o.AccessControlExposeHeaders = accessControlExposeHeaders
	return o
}

// SetAccessControlExposeHeaders sets the accessControlExposeHeaders to the files head forbidden response
func (o *FilesHeadForbidden) SetAccessControlExposeHeaders(accessControlExposeHeaders string) {
	o.AccessControlExposeHeaders = accessControlExposeHeaders
}

// WithTusResumable adds the tusResumable to the files head forbidden response
func (o *FilesHeadForbidden) WithTusResumable(tusResumable string) *FilesHeadForbidden {
	o.TusResumable = tusResumable
	return o
}

// SetTusResumable sets the tusResumable to the files head forbidden response
func (o *FilesHeadForbidden) SetTusResumable(tusResumable string) {
	o.TusResumable = tusResumable
}

// WriteResponse to the client
func (o *FilesHeadForbidden) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	// response header Access-Control-Expose-Headers

	accessControlExposeHeaders := o.AccessControlExposeHeaders
	if accessControlExposeHeaders != "" {
		rw.Header().Set("Access-Control-Expose-Headers", accessControlExposeHeaders)
	}

	// response header Tus-Resumable

	tusResumable := o.TusResumable
	if tusResumable != "" {
		rw.Header().Set("Tus-Resumable", tusResumable)
	}

	rw.Header().Del(runtime.HeaderContentType) //Remove Content-Type on empty responses

	rw.WriteHeader(403)
}

// FilesHeadNotFoundCode is the HTTP code returned for type FilesHeadNotFound
const FilesHeadNotFoundCode int = 404

/*FilesHeadNotFound If the resource is not found, the Server SHOULD return either the 404 Not Found, 410 Gone or 403 Forbidden status without the Upload-Offset header.

swagger:response filesHeadNotFound
*/
type FilesHeadNotFound struct {
	/*Needed to make browsers accept the additional headers used by
	the tus protocol.


	*/
	AccessControlExposeHeaders string `json:"Access-Control-Expose-Headers"`
	/*Protocol version

	 */
	TusResumable string `json:"Tus-Resumable"`
}

// NewFilesHeadNotFound creates FilesHeadNotFound with default headers values
func NewFilesHeadNotFound() *FilesHeadNotFound {

	return &FilesHeadNotFound{}
}

// WithAccessControlExposeHeaders adds the accessControlExposeHeaders to the files head not found response
func (o *FilesHeadNotFound) WithAccessControlExposeHeaders(accessControlExposeHeaders string) *FilesHeadNotFound {
	o.AccessControlExposeHeaders = accessControlExposeHeaders
	return o
}

// SetAccessControlExposeHeaders sets the accessControlExposeHeaders to the files head not found response
func (o *FilesHeadNotFound) SetAccessControlExposeHeaders(accessControlExposeHeaders string) {
	o.AccessControlExposeHeaders = accessControlExposeHeaders
}

// WithTusResumable adds the tusResumable to the files head not found response
func (o *FilesHeadNotFound) WithTusResumable(tusResumable string) *FilesHeadNotFound {
	o.TusResumable = tusResumable
	return o
}

// SetTusResumable sets the tusResumable to the files head not found response
func (o *FilesHeadNotFound) SetTusResumable(tusResumable string) {
	o.TusResumable = tusResumable
}

// WriteResponse to the client
func (o *FilesHeadNotFound) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	// response header Access-Control-Expose-Headers

	accessControlExposeHeaders := o.AccessControlExposeHeaders
	if accessControlExposeHeaders != "" {
		rw.Header().Set("Access-Control-Expose-Headers", accessControlExposeHeaders)
	}

	// response header Tus-Resumable

	tusResumable := o.TusResumable
	if tusResumable != "" {
		rw.Header().Set("Tus-Resumable", tusResumable)
	}

	rw.Header().Del(runtime.HeaderContentType) //Remove Content-Type on empty responses

	rw.WriteHeader(404)
}

// FilesHeadGoneCode is the HTTP code returned for type FilesHeadGone
const FilesHeadGoneCode int = 410

/*FilesHeadGone If the resource is not found, the Server SHOULD return either the 404 Not Found, 410 Gone or 403 Forbidden status without the Upload-Offset header.

swagger:response filesHeadGone
*/
type FilesHeadGone struct {
	/*Needed to make browsers accept the additional headers used by
	the tus protocol.


	*/
	AccessControlExposeHeaders string `json:"Access-Control-Expose-Headers"`
	/*Protocol version

	 */
	TusResumable string `json:"Tus-Resumable"`
}

// NewFilesHeadGone creates FilesHeadGone with default headers values
func NewFilesHeadGone() *FilesHeadGone {

	return &FilesHeadGone{}
}

// WithAccessControlExposeHeaders adds the accessControlExposeHeaders to the files head gone response
func (o *FilesHeadGone) WithAccessControlExposeHeaders(accessControlExposeHeaders string) *FilesHeadGone {
	o.AccessControlExposeHeaders = accessControlExposeHeaders
	return o
}

// SetAccessControlExposeHeaders sets the accessControlExposeHeaders to the files head gone response
func (o *FilesHeadGone) SetAccessControlExposeHeaders(accessControlExposeHeaders string) {
	o.AccessControlExposeHeaders = accessControlExposeHeaders
}

// WithTusResumable adds the tusResumable to the files head gone response
func (o *FilesHeadGone) WithTusResumable(tusResumable string) *FilesHeadGone {
	o.TusResumable = tusResumable
	return o
}

// SetTusResumable sets the tusResumable to the files head gone response
func (o *FilesHeadGone) SetTusResumable(tusResumable string) {
	o.TusResumable = tusResumable
}

// WriteResponse to the client
func (o *FilesHeadGone) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	// response header Access-Control-Expose-Headers

	accessControlExposeHeaders := o.AccessControlExposeHeaders
	if accessControlExposeHeaders != "" {
		rw.Header().Set("Access-Control-Expose-Headers", accessControlExposeHeaders)
	}

	// response header Tus-Resumable

	tusResumable := o.TusResumable
	if tusResumable != "" {
		rw.Header().Set("Tus-Resumable", tusResumable)
	}

	rw.Header().Del(runtime.HeaderContentType) //Remove Content-Type on empty responses

	rw.WriteHeader(410)
}

// FilesHeadPreconditionFailedCode is the HTTP code returned for type FilesHeadPreconditionFailed
const FilesHeadPreconditionFailedCode int = 412

/*FilesHeadPreconditionFailed Precondition Failed

swagger:response filesHeadPreconditionFailed
*/
type FilesHeadPreconditionFailed struct {
	/*Needed to make browsers accept the additional headers used by
	the tus protocol.


	*/
	AccessControlExposeHeaders string `json:"Access-Control-Expose-Headers"`
	/*Protocol version

	 */
	TusResumable string `json:"Tus-Resumable"`
	/*The Tus-Version response header MUST be a comma-separated list of protocol versions supported by the Server. The list MUST be sorted by Server's preference where the first one is the most preferred one.

	 */
	TusVersion string `json:"Tus-Version"`
}

// NewFilesHeadPreconditionFailed creates FilesHeadPreconditionFailed with default headers values
func NewFilesHeadPreconditionFailed() *FilesHeadPreconditionFailed {

	return &FilesHeadPreconditionFailed{}
}

// WithAccessControlExposeHeaders adds the accessControlExposeHeaders to the files head precondition failed response
func (o *FilesHeadPreconditionFailed) WithAccessControlExposeHeaders(accessControlExposeHeaders string) *FilesHeadPreconditionFailed {
	o.AccessControlExposeHeaders = accessControlExposeHeaders
	return o
}

// SetAccessControlExposeHeaders sets the accessControlExposeHeaders to the files head precondition failed response
func (o *FilesHeadPreconditionFailed) SetAccessControlExposeHeaders(accessControlExposeHeaders string) {
	o.AccessControlExposeHeaders = accessControlExposeHeaders
}

// WithTusResumable adds the tusResumable to the files head precondition failed response
func (o *FilesHeadPreconditionFailed) WithTusResumable(tusResumable string) *FilesHeadPreconditionFailed {
	o.TusResumable = tusResumable
	return o
}

// SetTusResumable sets the tusResumable to the files head precondition failed response
func (o *FilesHeadPreconditionFailed) SetTusResumable(tusResumable string) {
	o.TusResumable = tusResumable
}

// WithTusVersion adds the tusVersion to the files head precondition failed response
func (o *FilesHeadPreconditionFailed) WithTusVersion(tusVersion string) *FilesHeadPreconditionFailed {
	o.TusVersion = tusVersion
	return o
}

// SetTusVersion sets the tusVersion to the files head precondition failed response
func (o *FilesHeadPreconditionFailed) SetTusVersion(tusVersion string) {
	o.TusVersion = tusVersion
}

// WriteResponse to the client
func (o *FilesHeadPreconditionFailed) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	// response header Access-Control-Expose-Headers

	accessControlExposeHeaders := o.AccessControlExposeHeaders
	if accessControlExposeHeaders != "" {
		rw.Header().Set("Access-Control-Expose-Headers", accessControlExposeHeaders)
	}

	// response header Tus-Resumable

	tusResumable := o.TusResumable
	if tusResumable != "" {
		rw.Header().Set("Tus-Resumable", tusResumable)
	}

	// response header Tus-Version

	tusVersion := o.TusVersion
	if tusVersion != "" {
		rw.Header().Set("Tus-Version", tusVersion)
	}

	rw.Header().Del(runtime.HeaderContentType) //Remove Content-Type on empty responses

	rw.WriteHeader(412)
}

// FilesHeadServiceUnavailableCode is the HTTP code returned for type FilesHeadServiceUnavailable
const FilesHeadServiceUnavailableCode int = 503

/*FilesHeadServiceUnavailable Service Unavailable

swagger:response filesHeadServiceUnavailable
*/
type FilesHeadServiceUnavailable struct {

	/*
	  In: Body
	*/
	Payload *models.ErrorResponse `json:"body,omitempty"`
}

// NewFilesHeadServiceUnavailable creates FilesHeadServiceUnavailable with default headers values
func NewFilesHeadServiceUnavailable() *FilesHeadServiceUnavailable {

	return &FilesHeadServiceUnavailable{}
}

// WithPayload adds the payload to the files head service unavailable response
func (o *FilesHeadServiceUnavailable) WithPayload(payload *models.ErrorResponse) *FilesHeadServiceUnavailable {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the files head service unavailable response
func (o *FilesHeadServiceUnavailable) SetPayload(payload *models.ErrorResponse) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *FilesHeadServiceUnavailable) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(503)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}
