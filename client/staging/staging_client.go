// Code generated by go-swagger; DO NOT EDIT.

package staging

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

//go:generate mockery -name API -inpkg

// API is the interface of the staging client
type API interface {
	/*
	   CheckCloudNFSExportAddStatus checks the status of a nfs export add request for the cloud

	   Check the status of a nfs export add request for the cloud*/
	CheckCloudNFSExportAddStatus(ctx context.Context, params *CheckCloudNFSExportAddStatusParams) (*CheckCloudNFSExportAddStatusOK, error)
	/*
	   CheckCloudNFSExportRemoveStatus checks the status of a nfs export remove request for the cloud

	   Check the status of a nfs export remove request for the cloud*/
	CheckCloudNFSExportRemoveStatus(ctx context.Context, params *CheckCloudNFSExportRemoveStatusParams) (*CheckCloudNFSExportRemoveStatusOK, error)
	/*
	   CheckCompressToZipStatus checks the status of a transfer

	   Check the status of a transfer*/
	CheckCompressToZipStatus(ctx context.Context, params *CheckCompressToZipStatusParams) (*CheckCompressToZipStatusOK, error)
	/*
	   CheckDeletionStatus checks the status of a delete request

	   On successful query (200), the status provides information about the result:
	    - "Task still in the queue, or task does not exist": The request was not yet enqueued. Wait for a few seconds and retry
	    - "Task Failed, reason: <specific reason>": The dataset could not be deleted
	    - "Data deleted": The dataset was deleted successfully
	    - "In progress": The deletion is in progress, wait a few seconds and retry.
	*/
	CheckDeletionStatus(ctx context.Context, params *CheckDeletionStatusParams) (*CheckDeletionStatusOK, error)
	/*
	   CheckDuplicationStatus checks the status of duplication

	   Check the status of duplication. The status is given as:
	   - "Task still in the queue, or task does not exist": wait and retry.
	   - "In progress": wait and retry.
	   - "Task Failed, reason: <specific reason>": failure
	   - "Duplication completed": success; target_path provides the path.
	*/
	CheckDuplicationStatus(ctx context.Context, params *CheckDuplicationStatusParams) (*CheckDuplicationStatusOK, error)
	/*
	   CheckStageStatus checks the status of a transfer

	   On successful query (200), the status provides information about the result:
	    - "Task still in the queue, or task does not exist": The request was not yet enqueued. Wait for a few seconds and retry
	    - "Task Failed, reason: <specific reason>": The dataset could not be staged
	    - "Transfer completed": The transfer succeeded, and the data is in the target_path property.
	    - "In progress": The transfer is in progress, wait a few seconds and retry.
	*/
	CheckStageStatus(ctx context.Context, params *CheckStageStatusParams) (*CheckStageStatusOK, error)
	/*
	   CloudNFSExportAdd requests that an nfs export be created for an l r z cloud instance

	   Request that an nfs export be created for an LRZ cloud instance*/
	CloudNFSExportAdd(ctx context.Context, params *CloudNFSExportAddParams) (*CloudNFSExportAddCreated, error)
	/*
	   CloudNFSExportRemove requests that an nfs export be removed for an l r z cloud instance

	   Request that an nfs export be removed for an LRZ cloud instance*/
	CloudNFSExportRemove(ctx context.Context, params *CloudNFSExportRemoveParams) (*CloudNFSExportRemoveCreated, error)
	/*
	   CompressToZip creates a multipart zip file from a staging api source system source path combination

	   Creates a multipart zip file from a staging api source_system/source_path combination
	   If you have a tuple [project, access, internalID] and the current user, the corresponding path should be calculated by calculating the md5 hash of the project, and then:
	    - For public datasets: "public/proj"+hash+"/"+internalID
	    - For user datasets: "user/proj"+hash+"/"+user+"/"+internalID
	    - For project datasets: "project/proj"+hash+"/"+internalID
	*/
	CompressToZip(ctx context.Context, params *CompressToZipParams) (*CompressToZipCreated, error)
	/*
	   Delete this is called when a user request to delete data this is only allowed on the staging systems

	   This is called when a user request to delete data. This is only allowed on the staging systems.
	   If you have a tuple [project, access, internalID] and the current user, the corresponding path should be calculated by calculating the md5 hash of the project, and then:
	    - For public datasets: "public/proj"+hash+"/"+internalID
	    - For user datasets: "user/proj"+hash+"/"+user+"/"+internalID
	    - For project datasets: "project/proj"+hash+"/"+internalID
	*/
	Delete(ctx context.Context, params *DeleteParams) (*DeleteCreated, error)
	/*
	   Duplicate duplicates a dataset or subdataset by enqueuing the request for latter processing

	   Duplicate a dataset or subdataset (by enqueuing the request for latter processing)*/
	Duplicate(ctx context.Context, params *DuplicateParams) (*DuplicateCreated, error)
	/*
	   Stage stages a dataset or subdataset by enqueuing the request for latter processing

	   Stage a dataset or subdataset (by enqueuing the request for latter processing).
	   If you have a tuple [project, access, internalID] and the current user, the corresponding path should be calculated by calculating the md5 hash of the project, and then:
	    - For public datasets: "public/proj"+hash+"/"+internalID
	    - For user datasets: "user/proj"+hash+"/"+user+"/"+internalID
	    - For project datasets: "project/proj"+hash+"/"+internalID
	*/
	Stage(ctx context.Context, params *StageParams) (*StageCreated, error)
	/*
	   StagingInfo lists possible target source systems*/
	StagingInfo(ctx context.Context, params *StagingInfoParams) (*StagingInfoOK, error)
}

// New creates a new staging API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry, authInfo runtime.ClientAuthInfoWriter) *Client {
	return &Client{
		transport: transport,
		formats:   formats,
		authInfo:  authInfo,
	}
}

/*
Client for staging API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
	authInfo  runtime.ClientAuthInfoWriter
}

/*
CheckCloudNFSExportAddStatus checks the status of a nfs export add request for the cloud

Check the status of a nfs export add request for the cloud
*/
func (a *Client) CheckCloudNFSExportAddStatus(ctx context.Context, params *CheckCloudNFSExportAddStatusParams) (*CheckCloudNFSExportAddStatusOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CheckCloudNFSExportAddStatus",
		Method:             "GET",
		PathPattern:        "/dataset/cloud/add/{param}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CheckCloudNFSExportAddStatusReader{formats: a.formats},
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CheckCloudNFSExportAddStatusOK), nil

}

/*
CheckCloudNFSExportRemoveStatus checks the status of a nfs export remove request for the cloud

Check the status of a nfs export remove request for the cloud
*/
func (a *Client) CheckCloudNFSExportRemoveStatus(ctx context.Context, params *CheckCloudNFSExportRemoveStatusParams) (*CheckCloudNFSExportRemoveStatusOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CheckCloudNFSExportRemoveStatus",
		Method:             "GET",
		PathPattern:        "/dataset/cloud/remove/{param}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CheckCloudNFSExportRemoveStatusReader{formats: a.formats},
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CheckCloudNFSExportRemoveStatusOK), nil

}

/*
CheckCompressToZipStatus checks the status of a transfer

Check the status of a transfer
*/
func (a *Client) CheckCompressToZipStatus(ctx context.Context, params *CheckCompressToZipStatusParams) (*CheckCompressToZipStatusOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CheckCompressToZipStatus",
		Method:             "GET",
		PathPattern:        "/dataset/compress/zip/{request_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CheckCompressToZipStatusReader{formats: a.formats},
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CheckCompressToZipStatusOK), nil

}

/*
CheckDeletionStatus checks the status of a delete request

On successful query (200), the status provides information about the result:
 - "Task still in the queue, or task does not exist": The request was not yet enqueued. Wait for a few seconds and retry
 - "Task Failed, reason: <specific reason>": The dataset could not be deleted
 - "Data deleted": The dataset was deleted successfully
 - "In progress": The deletion is in progress, wait a few seconds and retry.

*/
func (a *Client) CheckDeletionStatus(ctx context.Context, params *CheckDeletionStatusParams) (*CheckDeletionStatusOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CheckDeletionStatus",
		Method:             "GET",
		PathPattern:        "/dataset/staging/delete/{request_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CheckDeletionStatusReader{formats: a.formats},
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CheckDeletionStatusOK), nil

}

/*
CheckDuplicationStatus checks the status of duplication

Check the status of duplication. The status is given as:
- "Task still in the queue, or task does not exist": wait and retry.
- "In progress": wait and retry.
- "Task Failed, reason: <specific reason>": failure
- "Duplication completed": success; target_path provides the path.

*/
func (a *Client) CheckDuplicationStatus(ctx context.Context, params *CheckDuplicationStatusParams) (*CheckDuplicationStatusOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CheckDuplicationStatus",
		Method:             "GET",
		PathPattern:        "/dataset/duplicate/{request_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CheckDuplicationStatusReader{formats: a.formats},
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CheckDuplicationStatusOK), nil

}

/*
CheckStageStatus checks the status of a transfer

On successful query (200), the status provides information about the result:
 - "Task still in the queue, or task does not exist": The request was not yet enqueued. Wait for a few seconds and retry
 - "Task Failed, reason: <specific reason>": The dataset could not be staged
 - "Transfer completed": The transfer succeeded, and the data is in the target_path property.
 - "In progress": The transfer is in progress, wait a few seconds and retry.

*/
func (a *Client) CheckStageStatus(ctx context.Context, params *CheckStageStatusParams) (*CheckStageStatusOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CheckStageStatus",
		Method:             "GET",
		PathPattern:        "/dataset/staging/stage/{request_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CheckStageStatusReader{formats: a.formats},
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CheckStageStatusOK), nil

}

/*
CloudNFSExportAdd requests that an nfs export be created for an l r z cloud instance

Request that an nfs export be created for an LRZ cloud instance
*/
func (a *Client) CloudNFSExportAdd(ctx context.Context, params *CloudNFSExportAddParams) (*CloudNFSExportAddCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CloudNFSExportAdd",
		Method:             "POST",
		PathPattern:        "/dataset/cloud/add/{param}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CloudNFSExportAddReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CloudNFSExportAddCreated), nil

}

/*
CloudNFSExportRemove requests that an nfs export be removed for an l r z cloud instance

Request that an nfs export be removed for an LRZ cloud instance
*/
func (a *Client) CloudNFSExportRemove(ctx context.Context, params *CloudNFSExportRemoveParams) (*CloudNFSExportRemoveCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CloudNFSExportRemove",
		Method:             "POST",
		PathPattern:        "/dataset/cloud/remove/{param}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CloudNFSExportRemoveReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CloudNFSExportRemoveCreated), nil

}

/*
CompressToZip creates a multipart zip file from a staging api source system source path combination

Creates a multipart zip file from a staging api source_system/source_path combination
If you have a tuple [project, access, internalID] and the current user, the corresponding path should be calculated by calculating the md5 hash of the project, and then:
 - For public datasets: "public/proj"+hash+"/"+internalID
 - For user datasets: "user/proj"+hash+"/"+user+"/"+internalID
 - For project datasets: "project/proj"+hash+"/"+internalID

*/
func (a *Client) CompressToZip(ctx context.Context, params *CompressToZipParams) (*CompressToZipCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CompressToZip",
		Method:             "POST",
		PathPattern:        "/dataset/compress/zip",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CompressToZipReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CompressToZipCreated), nil

}

/*
Delete this is called when a user request to delete data this is only allowed on the staging systems

This is called when a user request to delete data. This is only allowed on the staging systems.
If you have a tuple [project, access, internalID] and the current user, the corresponding path should be calculated by calculating the md5 hash of the project, and then:
 - For public datasets: "public/proj"+hash+"/"+internalID
 - For user datasets: "user/proj"+hash+"/"+user+"/"+internalID
 - For project datasets: "project/proj"+hash+"/"+internalID

*/
func (a *Client) Delete(ctx context.Context, params *DeleteParams) (*DeleteCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Delete",
		Method:             "DELETE",
		PathPattern:        "/dataset/staging/delete",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteCreated), nil

}

/*
Duplicate duplicates a dataset or subdataset by enqueuing the request for latter processing

Duplicate a dataset or subdataset (by enqueuing the request for latter processing)
*/
func (a *Client) Duplicate(ctx context.Context, params *DuplicateParams) (*DuplicateCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Duplicate",
		Method:             "POST",
		PathPattern:        "/dataset/duplicate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DuplicateReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DuplicateCreated), nil

}

/*
Stage stages a dataset or subdataset by enqueuing the request for latter processing

Stage a dataset or subdataset (by enqueuing the request for latter processing).
If you have a tuple [project, access, internalID] and the current user, the corresponding path should be calculated by calculating the md5 hash of the project, and then:
 - For public datasets: "public/proj"+hash+"/"+internalID
 - For user datasets: "user/proj"+hash+"/"+user+"/"+internalID
 - For project datasets: "project/proj"+hash+"/"+internalID

*/
func (a *Client) Stage(ctx context.Context, params *StageParams) (*StageCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "Stage",
		Method:             "POST",
		PathPattern:        "/dataset/staging/stage",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &StageReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*StageCreated), nil

}

/*
StagingInfo lists possible target source systems
*/
func (a *Client) StagingInfo(ctx context.Context, params *StagingInfoParams) (*StagingInfoOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "StagingInfo",
		Method:             "GET",
		PathPattern:        "/dataset/staging/info",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &StagingInfoReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*StagingInfoOK), nil

}
