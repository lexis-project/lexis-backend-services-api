// Code generated by go-swagger; DO NOT EDIT.

package data_set_management

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/lexis-project/lexis-backend-services-api.git/models"
)

// FilesHeadReader is a Reader for the FilesHead structure.
type FilesHeadReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *FilesHeadReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewFilesHeadOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 401:
		result := NewFilesHeadUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewFilesHeadForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewFilesHeadNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 410:
		result := NewFilesHeadGone()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 412:
		result := NewFilesHeadPreconditionFailed()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 503:
		result := NewFilesHeadServiceUnavailable()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewFilesHeadOK creates a FilesHeadOK with default headers values
func NewFilesHeadOK() *FilesHeadOK {
	return &FilesHeadOK{}
}

/*FilesHeadOK handles this case with default header values.

Returns offset
*/
type FilesHeadOK struct {
	/*Needed to make browsers accept the additional headers used by
	the tus protocol.

	*/
	AccessControlExposeHeaders string

	CacheControl string
	/*Protocol version
	 */
	TusResumable string
	/*If the size of the upload is known, the Server MUST include the Upload-Length header in the response.
	 */
	UploadLength int64
	/*The Upload-Offset request and response header indicates a byte offset within a resource. The value MUST be a non-negative integer. Offset at which the upload should be continued.
	 */
	UploadOffset int64
}

func (o *FilesHeadOK) Error() string {
	return fmt.Sprintf("[HEAD /dataset/upload/{id}][%d] filesHeadOK ", 200)
}

func (o *FilesHeadOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response header Access-Control-Expose-Headers
	o.AccessControlExposeHeaders = response.GetHeader("Access-Control-Expose-Headers")

	// response header Cache-Control
	o.CacheControl = response.GetHeader("Cache-Control")

	// response header Tus-Resumable
	o.TusResumable = response.GetHeader("Tus-Resumable")

	// response header Upload-Length
	uploadLength, err := swag.ConvertInt64(response.GetHeader("Upload-Length"))
	if err != nil {
		return errors.InvalidType("Upload-Length", "header", "int64", response.GetHeader("Upload-Length"))
	}
	o.UploadLength = uploadLength

	// response header Upload-Offset
	uploadOffset, err := swag.ConvertInt64(response.GetHeader("Upload-Offset"))
	if err != nil {
		return errors.InvalidType("Upload-Offset", "header", "int64", response.GetHeader("Upload-Offset"))
	}
	o.UploadOffset = uploadOffset

	return nil
}

// NewFilesHeadUnauthorized creates a FilesHeadUnauthorized with default headers values
func NewFilesHeadUnauthorized() *FilesHeadUnauthorized {
	return &FilesHeadUnauthorized{}
}

/*FilesHeadUnauthorized handles this case with default header values.

Authorization failed
*/
type FilesHeadUnauthorized struct {
	Payload *models.ErrorResponse
}

func (o *FilesHeadUnauthorized) Error() string {
	return fmt.Sprintf("[HEAD /dataset/upload/{id}][%d] filesHeadUnauthorized  %+v", 401, o.Payload)
}

func (o *FilesHeadUnauthorized) GetPayload() *models.ErrorResponse {
	return o.Payload
}

func (o *FilesHeadUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorResponse)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewFilesHeadForbidden creates a FilesHeadForbidden with default headers values
func NewFilesHeadForbidden() *FilesHeadForbidden {
	return &FilesHeadForbidden{}
}

/*FilesHeadForbidden handles this case with default header values.

If the resource is not found, the Server SHOULD return either the 404 Not Found, 410 Gone or 403 Forbidden status without the Upload-Offset header.
*/
type FilesHeadForbidden struct {
	/*Needed to make browsers accept the additional headers used by
	the tus protocol.

	*/
	AccessControlExposeHeaders string
	/*Protocol version
	 */
	TusResumable string
}

func (o *FilesHeadForbidden) Error() string {
	return fmt.Sprintf("[HEAD /dataset/upload/{id}][%d] filesHeadForbidden ", 403)
}

func (o *FilesHeadForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response header Access-Control-Expose-Headers
	o.AccessControlExposeHeaders = response.GetHeader("Access-Control-Expose-Headers")

	// response header Tus-Resumable
	o.TusResumable = response.GetHeader("Tus-Resumable")

	return nil
}

// NewFilesHeadNotFound creates a FilesHeadNotFound with default headers values
func NewFilesHeadNotFound() *FilesHeadNotFound {
	return &FilesHeadNotFound{}
}

/*FilesHeadNotFound handles this case with default header values.

If the resource is not found, the Server SHOULD return either the 404 Not Found, 410 Gone or 403 Forbidden status without the Upload-Offset header.
*/
type FilesHeadNotFound struct {
	/*Needed to make browsers accept the additional headers used by
	the tus protocol.

	*/
	AccessControlExposeHeaders string
	/*Protocol version
	 */
	TusResumable string
}

func (o *FilesHeadNotFound) Error() string {
	return fmt.Sprintf("[HEAD /dataset/upload/{id}][%d] filesHeadNotFound ", 404)
}

func (o *FilesHeadNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response header Access-Control-Expose-Headers
	o.AccessControlExposeHeaders = response.GetHeader("Access-Control-Expose-Headers")

	// response header Tus-Resumable
	o.TusResumable = response.GetHeader("Tus-Resumable")

	return nil
}

// NewFilesHeadGone creates a FilesHeadGone with default headers values
func NewFilesHeadGone() *FilesHeadGone {
	return &FilesHeadGone{}
}

/*FilesHeadGone handles this case with default header values.

If the resource is not found, the Server SHOULD return either the 404 Not Found, 410 Gone or 403 Forbidden status without the Upload-Offset header.
*/
type FilesHeadGone struct {
	/*Needed to make browsers accept the additional headers used by
	the tus protocol.

	*/
	AccessControlExposeHeaders string
	/*Protocol version
	 */
	TusResumable string
}

func (o *FilesHeadGone) Error() string {
	return fmt.Sprintf("[HEAD /dataset/upload/{id}][%d] filesHeadGone ", 410)
}

func (o *FilesHeadGone) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response header Access-Control-Expose-Headers
	o.AccessControlExposeHeaders = response.GetHeader("Access-Control-Expose-Headers")

	// response header Tus-Resumable
	o.TusResumable = response.GetHeader("Tus-Resumable")

	return nil
}

// NewFilesHeadPreconditionFailed creates a FilesHeadPreconditionFailed with default headers values
func NewFilesHeadPreconditionFailed() *FilesHeadPreconditionFailed {
	return &FilesHeadPreconditionFailed{}
}

/*FilesHeadPreconditionFailed handles this case with default header values.

Precondition Failed
*/
type FilesHeadPreconditionFailed struct {
	/*Needed to make browsers accept the additional headers used by
	the tus protocol.

	*/
	AccessControlExposeHeaders string
	/*Protocol version
	 */
	TusResumable string
	/*The Tus-Version response header MUST be a comma-separated list of protocol versions supported by the Server. The list MUST be sorted by Server's preference where the first one is the most preferred one.
	 */
	TusVersion string
}

func (o *FilesHeadPreconditionFailed) Error() string {
	return fmt.Sprintf("[HEAD /dataset/upload/{id}][%d] filesHeadPreconditionFailed ", 412)
}

func (o *FilesHeadPreconditionFailed) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response header Access-Control-Expose-Headers
	o.AccessControlExposeHeaders = response.GetHeader("Access-Control-Expose-Headers")

	// response header Tus-Resumable
	o.TusResumable = response.GetHeader("Tus-Resumable")

	// response header Tus-Version
	o.TusVersion = response.GetHeader("Tus-Version")

	return nil
}

// NewFilesHeadServiceUnavailable creates a FilesHeadServiceUnavailable with default headers values
func NewFilesHeadServiceUnavailable() *FilesHeadServiceUnavailable {
	return &FilesHeadServiceUnavailable{}
}

/*FilesHeadServiceUnavailable handles this case with default header values.

Service Unavailable
*/
type FilesHeadServiceUnavailable struct {
	Payload *models.ErrorResponse
}

func (o *FilesHeadServiceUnavailable) Error() string {
	return fmt.Sprintf("[HEAD /dataset/upload/{id}][%d] filesHeadServiceUnavailable  %+v", 503, o.Payload)
}

func (o *FilesHeadServiceUnavailable) GetPayload() *models.ErrorResponse {
	return o.Payload
}

func (o *FilesHeadServiceUnavailable) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorResponse)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}
