// Code generated by go-swagger; DO NOT EDIT.

package data_set_management

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/lexis-project/lexis-backend-services-api.git/models"
)

// FilePatchReader is a Reader for the FilePatch structure.
type FilePatchReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *FilePatchReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewFilePatchNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewFilePatchBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 401:
		result := NewFilePatchUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewFilePatchForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewFilePatchNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 410:
		result := NewFilePatchGone()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 412:
		result := NewFilePatchPreconditionFailed()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 415:
		result := NewFilePatchUnsupportedMediaType()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 460:
		result := NewFilePatchStatus460()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 503:
		result := NewFilePatchServiceUnavailable()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewFilePatchNoContent creates a FilePatchNoContent with default headers values
func NewFilePatchNoContent() *FilePatchNoContent {
	return &FilePatchNoContent{}
}

/*FilePatchNoContent handles this case with default header values.

Upload offset was updated
*/
type FilePatchNoContent struct {
	/*Needed to make browsers accept the additional headers used by
	the tus protocol.

	*/
	AccessControlExposeHeaders string
	/*Protocol version
	 */
	TusResumable string
	/*Added by the expiration extension. The Upload-Expires response header indicates the time after which the unfinished upload expires. A Server MAY wish to remove incomplete uploads after a given period of time to prevent abandoned uploads from taking up extra storage. The Client SHOULD use this header to determine if an upload is still valid before attempting to resume the upload. This header MUST be included in every PATCH response if the upload is going to expire. If the expiration is known at the creation, the Upload-Expires header MUST be included in the response to the initial POST request. Its value MAY change over time. If a Client does attempt to resume an upload which has since been removed by the Server, the Server SHOULD respond with the 404 Not Found or 410 Gone status. The latter one SHOULD be used if the Server is keeping track of expired uploads. In both cases the Client SHOULD start a new upload. The value of the Upload-Expires header MUST be in RFC 7231 datetime format.
	 */
	UploadExpires string
	/*The Upload-Offset request and response header indicates a byte offset within a resource. The value MUST be a non-negative integer.
	 */
	UploadOffset int64
}

func (o *FilePatchNoContent) Error() string {
	return fmt.Sprintf("[PATCH /dataset/upload/{id}][%d] filePatchNoContent ", 204)
}

func (o *FilePatchNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response header Access-Control-Expose-Headers
	o.AccessControlExposeHeaders = response.GetHeader("Access-Control-Expose-Headers")

	// response header Tus-Resumable
	o.TusResumable = response.GetHeader("Tus-Resumable")

	// response header Upload-Expires
	o.UploadExpires = response.GetHeader("Upload-Expires")

	// response header Upload-Offset
	uploadOffset, err := swag.ConvertInt64(response.GetHeader("Upload-Offset"))
	if err != nil {
		return errors.InvalidType("Upload-Offset", "header", "int64", response.GetHeader("Upload-Offset"))
	}
	o.UploadOffset = uploadOffset

	return nil
}

// NewFilePatchBadRequest creates a FilePatchBadRequest with default headers values
func NewFilePatchBadRequest() *FilePatchBadRequest {
	return &FilePatchBadRequest{}
}

/*FilePatchBadRequest handles this case with default header values.

Added by the checksum extension. The checksum algorithm is not supported by the server
*/
type FilePatchBadRequest struct {
	/*Needed to make browsers accept the additional headers used by
	the tus protocol.

	*/
	AccessControlExposeHeaders string
	/*Protocol version
	 */
	TusResumable string
}

func (o *FilePatchBadRequest) Error() string {
	return fmt.Sprintf("[PATCH /dataset/upload/{id}][%d] filePatchBadRequest ", 400)
}

func (o *FilePatchBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response header Access-Control-Expose-Headers
	o.AccessControlExposeHeaders = response.GetHeader("Access-Control-Expose-Headers")

	// response header Tus-Resumable
	o.TusResumable = response.GetHeader("Tus-Resumable")

	return nil
}

// NewFilePatchUnauthorized creates a FilePatchUnauthorized with default headers values
func NewFilePatchUnauthorized() *FilePatchUnauthorized {
	return &FilePatchUnauthorized{}
}

/*FilePatchUnauthorized handles this case with default header values.

Authorization failed
*/
type FilePatchUnauthorized struct {
	Payload *models.ErrorResponse
}

func (o *FilePatchUnauthorized) Error() string {
	return fmt.Sprintf("[PATCH /dataset/upload/{id}][%d] filePatchUnauthorized  %+v", 401, o.Payload)
}

func (o *FilePatchUnauthorized) GetPayload() *models.ErrorResponse {
	return o.Payload
}

func (o *FilePatchUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorResponse)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewFilePatchForbidden creates a FilePatchForbidden with default headers values
func NewFilePatchForbidden() *FilePatchForbidden {
	return &FilePatchForbidden{}
}

/*FilePatchForbidden handles this case with default header values.

In the concatenation extension, the Server MUST respond with the 403 Forbidden status to PATCH requests against a final upload URL and MUST NOT modify the final or its partial uploads.
*/
type FilePatchForbidden struct {
	/*Needed to make browsers accept the additional headers used by
	the tus protocol.

	*/
	AccessControlExposeHeaders string
	/*Protocol version
	 */
	TusResumable string
}

func (o *FilePatchForbidden) Error() string {
	return fmt.Sprintf("[PATCH /dataset/upload/{id}][%d] filePatchForbidden ", 403)
}

func (o *FilePatchForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response header Access-Control-Expose-Headers
	o.AccessControlExposeHeaders = response.GetHeader("Access-Control-Expose-Headers")

	// response header Tus-Resumable
	o.TusResumable = response.GetHeader("Tus-Resumable")

	return nil
}

// NewFilePatchNotFound creates a FilePatchNotFound with default headers values
func NewFilePatchNotFound() *FilePatchNotFound {
	return &FilePatchNotFound{}
}

/*FilePatchNotFound handles this case with default header values.

PATCH request against a non-existent resource
*/
type FilePatchNotFound struct {
	/*Needed to make browsers accept the additional headers used by
	the tus protocol.

	*/
	AccessControlExposeHeaders string
	/*Protocol version
	 */
	TusResumable string
}

func (o *FilePatchNotFound) Error() string {
	return fmt.Sprintf("[PATCH /dataset/upload/{id}][%d] filePatchNotFound ", 404)
}

func (o *FilePatchNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response header Access-Control-Expose-Headers
	o.AccessControlExposeHeaders = response.GetHeader("Access-Control-Expose-Headers")

	// response header Tus-Resumable
	o.TusResumable = response.GetHeader("Tus-Resumable")

	return nil
}

// NewFilePatchGone creates a FilePatchGone with default headers values
func NewFilePatchGone() *FilePatchGone {
	return &FilePatchGone{}
}

/*FilePatchGone handles this case with default header values.

PATCH request against a non-existent resource
*/
type FilePatchGone struct {
	/*Needed to make browsers accept the additional headers used by
	the tus protocol.

	*/
	AccessControlExposeHeaders string
	/*Protocol version
	 */
	TusResumable string
}

func (o *FilePatchGone) Error() string {
	return fmt.Sprintf("[PATCH /dataset/upload/{id}][%d] filePatchGone ", 410)
}

func (o *FilePatchGone) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response header Access-Control-Expose-Headers
	o.AccessControlExposeHeaders = response.GetHeader("Access-Control-Expose-Headers")

	// response header Tus-Resumable
	o.TusResumable = response.GetHeader("Tus-Resumable")

	return nil
}

// NewFilePatchPreconditionFailed creates a FilePatchPreconditionFailed with default headers values
func NewFilePatchPreconditionFailed() *FilePatchPreconditionFailed {
	return &FilePatchPreconditionFailed{}
}

/*FilePatchPreconditionFailed handles this case with default header values.

Precondition Failed
*/
type FilePatchPreconditionFailed struct {
	/*Needed to make browsers accept the additional headers used by
	the tus protocol.

	*/
	AccessControlExposeHeaders string
	/*Protocol version
	 */
	TusResumable string
	/*The Tus-Version response header MUST be a comma-separated list of protocol versions supported by the Server. The list MUST be sorted by Server's preference where the first one is the most preferred one.
	 */
	TusVersion string
}

func (o *FilePatchPreconditionFailed) Error() string {
	return fmt.Sprintf("[PATCH /dataset/upload/{id}][%d] filePatchPreconditionFailed ", 412)
}

func (o *FilePatchPreconditionFailed) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response header Access-Control-Expose-Headers
	o.AccessControlExposeHeaders = response.GetHeader("Access-Control-Expose-Headers")

	// response header Tus-Resumable
	o.TusResumable = response.GetHeader("Tus-Resumable")

	// response header Tus-Version
	o.TusVersion = response.GetHeader("Tus-Version")

	return nil
}

// NewFilePatchUnsupportedMediaType creates a FilePatchUnsupportedMediaType with default headers values
func NewFilePatchUnsupportedMediaType() *FilePatchUnsupportedMediaType {
	return &FilePatchUnsupportedMediaType{}
}

/*FilePatchUnsupportedMediaType handles this case with default header values.

Content-Type was not application/offset+octet-stream
*/
type FilePatchUnsupportedMediaType struct {
	/*Needed to make browsers accept the additional headers used by
	the tus protocol.

	*/
	AccessControlExposeHeaders string
	/*Protocol version
	 */
	TusResumable string
}

func (o *FilePatchUnsupportedMediaType) Error() string {
	return fmt.Sprintf("[PATCH /dataset/upload/{id}][%d] filePatchUnsupportedMediaType ", 415)
}

func (o *FilePatchUnsupportedMediaType) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response header Access-Control-Expose-Headers
	o.AccessControlExposeHeaders = response.GetHeader("Access-Control-Expose-Headers")

	// response header Tus-Resumable
	o.TusResumable = response.GetHeader("Tus-Resumable")

	return nil
}

// NewFilePatchStatus460 creates a FilePatchStatus460 with default headers values
func NewFilePatchStatus460() *FilePatchStatus460 {
	return &FilePatchStatus460{}
}

/*FilePatchStatus460 handles this case with default header values.

Added by the checksum extension. Checksums mismatch
*/
type FilePatchStatus460 struct {
	/*Needed to make browsers accept the additional headers used by
	the tus protocol.

	*/
	AccessControlExposeHeaders string
	/*Protocol version
	 */
	TusResumable string
}

func (o *FilePatchStatus460) Error() string {
	return fmt.Sprintf("[PATCH /dataset/upload/{id}][%d] filePatchStatus460 ", 460)
}

func (o *FilePatchStatus460) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response header Access-Control-Expose-Headers
	o.AccessControlExposeHeaders = response.GetHeader("Access-Control-Expose-Headers")

	// response header Tus-Resumable
	o.TusResumable = response.GetHeader("Tus-Resumable")

	return nil
}

// NewFilePatchServiceUnavailable creates a FilePatchServiceUnavailable with default headers values
func NewFilePatchServiceUnavailable() *FilePatchServiceUnavailable {
	return &FilePatchServiceUnavailable{}
}

/*FilePatchServiceUnavailable handles this case with default header values.

Service Unavailable
*/
type FilePatchServiceUnavailable struct {
	Payload *models.ErrorResponse
}

func (o *FilePatchServiceUnavailable) Error() string {
	return fmt.Sprintf("[PATCH /dataset/upload/{id}][%d] filePatchServiceUnavailable  %+v", 503, o.Payload)
}

func (o *FilePatchServiceUnavailable) GetPayload() *models.ErrorResponse {
	return o.Payload
}

func (o *FilePatchServiceUnavailable) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorResponse)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}
