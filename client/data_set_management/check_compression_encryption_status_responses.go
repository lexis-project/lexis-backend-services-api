// Code generated by go-swagger; DO NOT EDIT.

package data_set_management

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"

	"github.com/lexis-project/lexis-backend-services-api.git/models"
)

// CheckCompressionEncryptionStatusReader is a Reader for the CheckCompressionEncryptionStatus structure.
type CheckCompressionEncryptionStatusReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *CheckCompressionEncryptionStatusReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewCheckCompressionEncryptionStatusOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewCheckCompressionEncryptionStatusBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 401:
		result := NewCheckCompressionEncryptionStatusUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewCheckCompressionEncryptionStatusNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 414:
		result := NewCheckCompressionEncryptionStatusRequestURITooLong()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewCheckCompressionEncryptionStatusInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewCheckCompressionEncryptionStatusOK creates a CheckCompressionEncryptionStatusOK with default headers values
func NewCheckCompressionEncryptionStatusOK() *CheckCompressionEncryptionStatusOK {
	return &CheckCompressionEncryptionStatusOK{}
}

/*CheckCompressionEncryptionStatusOK handles this case with default header values.

This means that the status has been returned to the user in the response body.
*/
type CheckCompressionEncryptionStatusOK struct {
	Payload *CheckCompressionEncryptionStatusOKBody
}

func (o *CheckCompressionEncryptionStatusOK) Error() string {
	return fmt.Sprintf("[GET /dataset/encryption/compress_encrypt/{request_id}][%d] checkCompressionEncryptionStatusOK  %+v", 200, o.Payload)
}

func (o *CheckCompressionEncryptionStatusOK) GetPayload() *CheckCompressionEncryptionStatusOKBody {
	return o.Payload
}

func (o *CheckCompressionEncryptionStatusOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CheckCompressionEncryptionStatusOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCheckCompressionEncryptionStatusBadRequest creates a CheckCompressionEncryptionStatusBadRequest with default headers values
func NewCheckCompressionEncryptionStatusBadRequest() *CheckCompressionEncryptionStatusBadRequest {
	return &CheckCompressionEncryptionStatusBadRequest{}
}

/*CheckCompressionEncryptionStatusBadRequest handles this case with default header values.

This means that the request ID given by the user is incorrect.
*/
type CheckCompressionEncryptionStatusBadRequest struct {
	Payload *models.ErrorResponse
}

func (o *CheckCompressionEncryptionStatusBadRequest) Error() string {
	return fmt.Sprintf("[GET /dataset/encryption/compress_encrypt/{request_id}][%d] checkCompressionEncryptionStatusBadRequest  %+v", 400, o.Payload)
}

func (o *CheckCompressionEncryptionStatusBadRequest) GetPayload() *models.ErrorResponse {
	return o.Payload
}

func (o *CheckCompressionEncryptionStatusBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorResponse)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCheckCompressionEncryptionStatusUnauthorized creates a CheckCompressionEncryptionStatusUnauthorized with default headers values
func NewCheckCompressionEncryptionStatusUnauthorized() *CheckCompressionEncryptionStatusUnauthorized {
	return &CheckCompressionEncryptionStatusUnauthorized{}
}

/*CheckCompressionEncryptionStatusUnauthorized handles this case with default header values.

This means that the user is not authenticated with keycloak and compression with encryption can't be triggered unless the user first log in with a valid user
*/
type CheckCompressionEncryptionStatusUnauthorized struct {
	Payload *models.ErrorResponse
}

func (o *CheckCompressionEncryptionStatusUnauthorized) Error() string {
	return fmt.Sprintf("[GET /dataset/encryption/compress_encrypt/{request_id}][%d] checkCompressionEncryptionStatusUnauthorized  %+v", 401, o.Payload)
}

func (o *CheckCompressionEncryptionStatusUnauthorized) GetPayload() *models.ErrorResponse {
	return o.Payload
}

func (o *CheckCompressionEncryptionStatusUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorResponse)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCheckCompressionEncryptionStatusNotFound creates a CheckCompressionEncryptionStatusNotFound with default headers values
func NewCheckCompressionEncryptionStatusNotFound() *CheckCompressionEncryptionStatusNotFound {
	return &CheckCompressionEncryptionStatusNotFound{}
}

/*CheckCompressionEncryptionStatusNotFound handles this case with default header values.

This means that the ID doesn't exist and thus a status can't be returned.
*/
type CheckCompressionEncryptionStatusNotFound struct {
	Payload *models.ErrorResponse
}

func (o *CheckCompressionEncryptionStatusNotFound) Error() string {
	return fmt.Sprintf("[GET /dataset/encryption/compress_encrypt/{request_id}][%d] checkCompressionEncryptionStatusNotFound  %+v", 404, o.Payload)
}

func (o *CheckCompressionEncryptionStatusNotFound) GetPayload() *models.ErrorResponse {
	return o.Payload
}

func (o *CheckCompressionEncryptionStatusNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorResponse)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCheckCompressionEncryptionStatusRequestURITooLong creates a CheckCompressionEncryptionStatusRequestURITooLong with default headers values
func NewCheckCompressionEncryptionStatusRequestURITooLong() *CheckCompressionEncryptionStatusRequestURITooLong {
	return &CheckCompressionEncryptionStatusRequestURITooLong{}
}

/*CheckCompressionEncryptionStatusRequestURITooLong handles this case with default header values.

This means that the the request ID is longer than the server is willing to interpret.
*/
type CheckCompressionEncryptionStatusRequestURITooLong struct {
	Payload *models.ErrorResponse
}

func (o *CheckCompressionEncryptionStatusRequestURITooLong) Error() string {
	return fmt.Sprintf("[GET /dataset/encryption/compress_encrypt/{request_id}][%d] checkCompressionEncryptionStatusRequestUriTooLong  %+v", 414, o.Payload)
}

func (o *CheckCompressionEncryptionStatusRequestURITooLong) GetPayload() *models.ErrorResponse {
	return o.Payload
}

func (o *CheckCompressionEncryptionStatusRequestURITooLong) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorResponse)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCheckCompressionEncryptionStatusInternalServerError creates a CheckCompressionEncryptionStatusInternalServerError with default headers values
func NewCheckCompressionEncryptionStatusInternalServerError() *CheckCompressionEncryptionStatusInternalServerError {
	return &CheckCompressionEncryptionStatusInternalServerError{}
}

/*CheckCompressionEncryptionStatusInternalServerError handles this case with default header values.

This means that something has gone wrong on the burst buffer. The user is advised to wait and send the request again.
*/
type CheckCompressionEncryptionStatusInternalServerError struct {
	Payload *models.ErrorResponse
}

func (o *CheckCompressionEncryptionStatusInternalServerError) Error() string {
	return fmt.Sprintf("[GET /dataset/encryption/compress_encrypt/{request_id}][%d] checkCompressionEncryptionStatusInternalServerError  %+v", 500, o.Payload)
}

func (o *CheckCompressionEncryptionStatusInternalServerError) GetPayload() *models.ErrorResponse {
	return o.Payload
}

func (o *CheckCompressionEncryptionStatusInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorResponse)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*CheckCompressionEncryptionStatusOKBody check compression encryption status o k body
swagger:model CheckCompressionEncryptionStatusOKBody
*/
type CheckCompressionEncryptionStatusOKBody struct {

	// status
	// Required: true
	Status *string `json:"status"`

	// Single path for encryption endpoints
	TargetPath string `json:"target_path,omitempty"`
}

// Validate validates this check compression encryption status o k body
func (o *CheckCompressionEncryptionStatusOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckCompressionEncryptionStatusOKBody) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("checkCompressionEncryptionStatusOK"+"."+"status", "body", o.Status); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckCompressionEncryptionStatusOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckCompressionEncryptionStatusOKBody) UnmarshalBinary(b []byte) error {
	var res CheckCompressionEncryptionStatusOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
